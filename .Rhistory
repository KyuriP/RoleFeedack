facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==1200) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = common_score,
y = avg, col = common_score)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==400) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = common_score,
y = avg, col = common_score)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==2000) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = common_score,
y = avg, col = common_score)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
loop_info <- loop_info2
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
total_similarity <- 0
count <- 0
for (i in 1:(length(cycles) - 1)) {
for (j in (i + 1):length(cycles)) {
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
total_similarity <- total_similarity + (intersection / union)
count <- count + 1
}
}
return(total_similarity / count)
}
loop_info
common_cycle
cycles <- loop_info |>
purrr::map(\(x) str_extract_all(x$id, "\\d") |>
map(\(x) as.numeric(x)[-1] |> unlist() )
)
cycles
View(cycles)
loop_info
### common nodes in cycle
# get the number of loops
loop_info <- all_networks |>
purrr::map(\(x) find_loops(create_adjacency_list(x), x) |>
purrr::list_rbind(names_to = "id") |>
filter(loop_length != 1) )
View(cycles)
cycles <- loop_info |>
purrr::map(\(x) str_extract_all(x$id, "\\d") |>
map(\(x) as.numeric(x)[-1] |> unlist() )
)
View(cycles)
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
total_similarity <- 0
count <- 0
for (i in 1:(length(cycles) - 1)) {
for (j in (i + 1):length(cycles)) {
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
total_similarity <- total_similarity + (intersection / union)
count <- count + 1
}
}
return(total_similarity / count)
}
cycles
calculate_jaccard_similarity(cycles[[2]])
calculate_jaccard_similarity(cycles[[3]])
length(cycles[[3]])
length(cycles[[2]])
calculate_jaccard_similarity(cycles[[2]])
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(NA) # Return NA if there are 0 or 1 cycles
}
combinations <- combn(length(cycles), 2, simplify = FALSE)
similarities <- map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
calculate_jaccard_similarity(cycles[[2]])
cycles[[2]]
str(cycles[[2]])
c <- list(
c(1, 2, 3),
c(2, 3, 4),
c(3, 4, 5)
)
calculate_jaccard_similarity(c)
rlang::last_trace()
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(NA) # Return NA if there are 0 or 1 cycles
}
combinations <- combn(seq_along(cycles), 2, simplify = FALSE)
similarities <- map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
c <- list(
c(1, 2, 3),
c(2, 3, 4),
c(3, 4, 5)
)
calculate_jaccard_similarity(c)
debugonce(calculate_jaccard_similarity)
calculate_jaccard_similarity(c)
View(combinations)
View(cycles)
?combn
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
# Handle cases where cycles length is 0 or 1
if (length(cycles) < 2) {
return(NA)  # or return a default value, depending on your needs
}
total_similarity <- 0
count <- 0
# Create a data frame from the cycles list
cycles_df <- tibble::tibble(cycle = cycles)
# Calculate pairwise Jaccard similarity using dplyr and purrr
cycles_df <- cycles_df %>%
mutate(index = row_number()) %>%
cross_join(cycles_df, by = character()) %>%
filter(index.x < index.y) %>%
mutate(intersection = map2_int(cycle.x, cycle.y, ~ length(intersect(.x, .y))),
union = map2_int(cycle.x, cycle.y, ~ length(union(.x, .y))),
similarity = intersection / union)
total_similarity <- sum(cycles_df$similarity)
count <- nrow(cycles_df)
return(total_similarity / count)
}
c <- list(
c(1, 2, 3),
c(2, 3, 4),
c(3, 4, 5)
)
calculate_jaccard_similarity(c)
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(NA) # Return NA if there are 0 or 1 cycles
}
combinations <- combn(seq_along(cycles), 2, simplify = FALSE)
similarities <- map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
c
seq_along(c)
vcombn(seq_along(c), 2, simplify = FALSE)
combn(seq_along(c), 2, simplify = FALSE)
combn(seq_along(c), 2)
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(NA) # Return NA if there are 0 or 1 cycles
}
combinations <- combn(seq_along(cycles), 2, simplify = FALSE)
similarities <- map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(intersect(cycles[[i]], cycles[[j]]))
union <- length(union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
calculate_jaccard_similarity(c)
c[[1]]
length(intersect(cycles[[1]], cycles[[2]]))
length(intersect(cycles[[1]], cycles[[3]]))
combinations <- combn(seq_along(c), 2, simplify = FALSE)
i <- combinations[1]
j <- combinations[2]
i
str(combinations)
combinations
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(NA) # Return NA if there are 0 or 1 cycles
}
combinations <- combn(seq_along(cycles), 2, simplify = FALSE)
similarities <- map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(base::intersect(cycles[[i]], cycles[[j]]))
union <- length(base::union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
calculate_jaccard_similarity(c)
calculate_jaccard_similarity(cycles[[2]])
cycles
loop_info
common_cycle <- loop_info |>
# extract node number without the first node that repeats
purrr::map(\(x) str_extract_all(x$id, "\\d", simplify = T)[,-1] |>
table(exclude = "") |> as.data.frame() %>%
dplyr::mutate(n_loop =  nrow(x),
# normalized overlap score1 = sum(cycle)count^2) / node_num * (cycle_num)^2
common_score = sum((Freq)^2) ,
nos1 = common_score / (9 * (n_loop)^2),
# normalized overlap score 2 = sum(cycle_count - 1) / node_num * (cycle_num)
nos2 = sum(Freq - 1) / (9 * n_loop))
)
View(cycles)
jaccard <- cycles |>
purrr::map(~calculate_jaccard_similarity)
View(jaccard)
jaccard <- cycles |>
purrr::map(~.x |> calculate_jaccard_similarity)
jaccard <- cycles |>
purrr::map(~.x |> calculate_jaccard_similarity())
View(jaccard)
jaccard[[1]]
jacaard |>
list_rbind()
jaccard |>
list_rbind()
a <- jaccard |>
list_rbind()
rlang::last_trace()
jaccard <- cycles |>
purrr::map_dbl(~.x |> calculate_jaccard_similarity())
a <- jaccard |>
mutate(replace_na(x,0))
# Function to calculate Jaccard Similarity Index
calculate_jaccard_similarity <- function(cycles) {
if (length(cycles) <= 1) {
return(0) # Return zero if there are 0 or 1 cycles
}
combinations <- utils::combn(seq_along(cycles), 2, simplify = FALSE)
similarities <- purrr::map_dbl(combinations, ~ {
i <- .x[1]
j <- .x[2]
intersection <- length(base::intersect(cycles[[i]], cycles[[j]]))
union <- length(base::union(cycles[[i]], cycles[[j]]))
intersection / union
})
mean(similarities, na.rm = TRUE)
}
jaccard <- cycles |>
purrr::map_dbl(~.x |> calculate_jaccard_similarity())
common_cycle <- loop_info |>
# extract node number without the first node that repeats
purrr::map(\(x) str_extract_all(x$id, "\\d", simplify = T)[,-1] |>
table(exclude = "") |> as.data.frame() %>%
dplyr::mutate(n_loop =  nrow(x),
# normalized overlap score1 = sum(cycle)count^2) / node_num * (cycle_num)^2
common_score = sum((Freq)^2) ,
nos1 = common_score / (9 * (n_loop)^2),
# normalized overlap score 2 = sum(cycle_count - 1) / node_num * (cycle_num)
nos2 = sum(Freq - 1) / (9 * n_loop))
)
nos1 <- common_cycle |> purrr::map_dbl(list("nos1", 1), .default = 0)
nos2 <- common_cycle |> purrr::map_dbl(list("nos2", 1), .default = 0)
# add it to the result
# comb_res <- rbind(original_res, res) |>
# mutate(nloop = rep(c(nloop_A, loop_numbers), each =3)) |>
comb_res <- rbind(original_res2, res2) |>
dplyr::mutate(nloop = rep(loop_numbers, each =5),
nos1 = rep(nos1, each = 5),
nos2 = rep(nos2, each = 5),
jaccard = rep(jaccard, each = 5)) |>
pivot_longer(!c(nloop, mat, common_score), names_to = "sim", values_to = "value") |>
dplyr::mutate(matr = stringr::str_extract_all(mat, "\\d+", simplify = T)[,1],
t = factor(stringr::str_extract_all(mat, "\\d+", simplify = T)[,2], levels = c("400", "800", "1200", "1600", "2000")),
sim = stringr::str_extract_all(sim, "\\d+", simplify = T),
# if loop number is higher than 20, then 20
nloop = ifelse(nloop >= 20, 20, nloop)
# group = case_when(
#   common_score == 0 ~ "0",
#   common_score <2 ~ "[1,2)",
#   common_score <3 ~ "[2,3)",
#   common_score <4 ~ "[3,4)",
#   common_score <5 ~ "[4,5)",
#   common_score <7 ~ "[5,6.5]")
)
comb_avg_res <- rbind(ori_avg_res, avg_res) |>
dplyr::mutate(nloop = rep(loop_numbers, each =5),
nos1 = rep(nos1, each = 5),
nos2 = rep(nos2, each = 5),
jaccard = rep(jaccard, each = 5)) |>
# pivot_longer(!c(nloop, mat, common_score), names_to = "sim", values_to = "value") |>
dplyr::mutate(matr = stringr::str_extract_all(mat, "\\d+", simplify = T)[,1],
t = factor(stringr::str_extract_all(mat, "\\d+", simplify = T)[,2], levels = c("400", "800", "1200", "1600", "2000")),
# if loop number is higher than 20, then 20
nloop = ifelse(nloop >= 20, 20, nloop),
group = case_when(
nos1 < 0.05 ~ "<0.05",
nos1 <0.10 ~ "<0.10",
nos1 <0.15 ~ "<0.15",
nos1 <0.20 ~ "<0.20",
nos1 >= 0.20 ~ "0.20+",
)
)
# boxplot _ number feedback loop
comb_avg_res |> filter(t==2000) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = jaccard,
y = avg, col = jaccard)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
hist(jaccard)
# boxplot _ number feedback loop
comb_avg_res |> filter(t==2000) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos2,
y = avg, col = nos2)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==400) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos2,
y = avg, col = nos2)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==1200) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos2,
y = avg, col = nos2)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==1200) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos1,
y = avg, col = nos1)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==2000) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos1,
y = avg, col = nos1)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
# boxplot _ number feedback loop
comb_avg_res |> filter(t==800) |>
# ggplot(aes(x = factor(nloop),
#              y = avg, fill = common_score, col = common_score)) +
ggplot(aes(x = nos1,
y = avg, col = nos1)) +
geom_point(
size = 1,
alpha = 0.2) +
# geom_boxplot(width = .2,
#              outlier.alpha = 0.1,
#              #outlier.size = 0.5,
#              outlier.size = 0,
#              alpha = 0.2,
# position = position_dodge(width = 0.5))  +
geom_flat_violin(position = position_nudge(x = .2),
alpha = 0.4,
adjust = 1.1,
trim = T) +
facet_wrap(~factor(nloop))
warnings()
2&17
2^17
help("remove.edge.attribute")
??remove.edge.attribute
View(cycles)
jaccard
hist(jaccard)
version()
